#pragma kernel ClearVisible
#pragma kernel StampVisible
#pragma kernel AccumulateExplored
// Textures
RWTexture2D<float> _Visible;
RWTexture2D<float> _Explored;

// Units: float3(xWorld, zWorld, level)
StructuredBuffer<float3> _Units;
int _UnitCount;
int2 _FogDim;
float3 _WorldMin;
float3 _WorldMax;

// ----------------- CLEAR VISIBLE -----------------
[numthreads(8, 8, 1)]
void ClearVisible(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _FogDim.x || id.y >= _FogDim.y)
        return;
    _Visible[id.xy] = 0;
}
// Dispatch as: (unitCount, maxRadius*2+1, maxRadius*2+1)
[numthreads(64, 1, 1)]
void StampVisible(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= _UnitCount)
        return;
    
    float3 u = _Units[index];
    float worldX = u.x;
    float worldZ = u.y;
    int level = (int) u.z;
    
    // Convert to pixel coordinates
    float px = (worldX - _WorldMin.x) * _FogDim.x / (_WorldMax.x - _WorldMin.x);
    float py = (worldZ - _WorldMin.z) * _FogDim.y / (_WorldMax.z - _WorldMin.z);
    int cx = (int) px;
    int cy = (int) py;
    
    // Calculate bounds once
    int minX = max(0, cx - level);
    int maxX = min((int) _FogDim.x - 1, cx + level);
    int minY = max(0, cy - level);
    int maxY = min((int) _FogDim.y - 1, cy + level);
    
    // Precompute level squared for distance check
    float radiusSq = (float) (level * level);
    
    // Simple nested loop - GPU handles this efficiently
    for (int y = minY; y <= maxY; y++)
    {
        for (int x = minX; x <= maxX; x++)
        {
            // Euclidean distance check (circular area)
            int dx = x - cx;
            int dy = y - cy;
            float distSq = (float) (dx * dx + dy * dy);
            
            if (distSq <= radiusSq)
            {
                _Visible[uint2(x, y)] = 1;
            }
        }
    }
}
[numthreads(8, 8, 1)]
void AccumulateExplored(uint3 id : SV_DispatchThreadID)
{
    uint2 p = id.xy;

    float v = _Visible[p];
    float e = _Explored[p];

    // explored stays 1 if ever seen
    if (v > e)
        _Explored[p] = v;
}